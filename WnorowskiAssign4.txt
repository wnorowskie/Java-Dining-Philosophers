Eric Wnorowski
Professor Marc Smith
CS377 Parallel Programming
Assign 4: Java Dining Philosophers

    This fourth assignment was obviously similar to our previous assignment as both look to tackle the Diniing Philosophers problem. Last assignment we tackled the problem from the perspective of the UPC programming language by using upc_unlock() and upc_lock(). So I already had a very good understanding of both the Dining Philosophers and the idea of synchronization amongst the philosophers. Now for this assignment we are looking to replicate the same methods in Java. As I learned in my last assignment it is better to gain an understanding of the functions prior to jumping into coding. So I took some time to look over the given example of synchronized methods, and then looked online for my examples of synchonized code blocks. The biggest change is that we are no longer referencing our threads, but rather specific philosophers. Similarly to how the last assignment is structured I first tried to tackle the issue by making philosophers wait for their chopsticks.
    This first method requires synchronized code blocks, and through my research I understood these code blocks would act upon the objects (or chopsticks). So when one philosopher enters the synchronized block, no other philosopher can act on that same chopstick. So I created a Chopstick and Chopsticks class that created an array of chopsticks to create the shared objects. This class also included getRight() and getLeft() methods that when given a philosophers ID it returns the proper left or right chopstick object. This methodology is similar to the approach used by the UPC assignment, except objects are being synchronized rather than threads. Therefore, I replicated that assignment by making all philosophers with an odd ID to try to pick up their left chopstick then their right, even philosophers attempt to pick up their right chopstick then their left. Using these stratgies I was able to have the program run without deadlocking.
    The second method required synchornized methods and implemented the third strategy of introducing a waiter. Using the example given to us it was relatively easy to implement. Rather than limiting the chopsticks that philosophers can pick up this strategy just limits the amount of philosophers that can sit down at any given time. Using the variable num_seated I was able to regulate the number of philosphers sitting at any given time, to prevent having to worry about two philosophers trying to use the same chopstick. At first I ran into some deadlocking issues, but that was because I was not increasing the num_seated variable within the while() loop that regulated the number of philosophers. After making this quick edit I no longer ran into issues of deadlocking. Therefore I was able to successfully implement the synchornized methods through the waiter class.
    Overall this assignment deepened my understanding of the dining philosophers problem, and showed its relevance across multiple programming languages. I was not aware of Java synchronized methods prior to this assignment and had never considered using it in prior problems. These assignments have really opened my eyes to the capabilities of parallel programming. I am excited to continue to learn more!
